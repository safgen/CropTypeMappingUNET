import tensorflow as tf
import subprocess


def doPrediction(out_image_base, user_folder, kernel_buffer, region):
  """Perform inference on exported imagery, upload to Earth Engine.
  """

  print('Looking for TFRecord files...')

  # Get a list of all the files in the output bucket.
  filesList = subprocess.run(['ls', FOLDER], stdout=subprocess.PIPE).stdout.decode("utf-8").splitlines()
  # print(filesList)
  # Get only the files generated by the image export.
  exportFilesList = [s for s in filesList if out_image_base in s]

  # Get the list of image files and the JSON mixer file.
  imageFilesList = []
  jsonFile = None
  for f in exportFilesList:
    if f.endswith('.tfrecord.gz'):
      imageFilesList.append(FOLDER+'/'+f)
    elif f.endswith('.json'):
      jsonFile = f

  # Make sure the files are in the right order.
  imageFilesList.sort()

  from pprint import pprint
  pprint(imageFilesList)
  print(jsonFile)

  import json
  # Load the contents of the mixer file to a JSON object.
  jsonText = subprocess.run(['cat', FOLDER+'/' + jsonFile], stdout=subprocess.PIPE).stdout.decode("utf-8")
  # print(jsonText)
  # Get a single string w/ newlines from the IPython.utils.text.SList
  mixer = json.loads(jsonText)
  pprint(mixer)
  patches = mixer['totalPatches']

  # Get set up for prediction.
  x_buffer = int(kernel_buffer[0] / 2)
  y_buffer = int(kernel_buffer[1] / 2)

  buffered_shape = [
      KERNEL_SHAPE[0] + kernel_buffer[0],
      KERNEL_SHAPE[1] + kernel_buffer[1]]

  imageColumns = [
    tf.io.FixedLenFeature(shape=buffered_shape, dtype=tf.float32) 
      for k in BANDS
  ]

  imageFeaturesDict = dict(zip(BANDS, imageColumns))

  def parse_image(example_proto):
    return tf.io.parse_single_example(example_proto, imageFeaturesDict)

  def toTupleImage(inputs):
    inputsList = [inputs.get(key) for key in BANDS]
    stacked = tf.stack(inputsList, axis=0)
    stacked = tf.transpose(stacked, [1, 2, 0])
    return stacked

   # Create a dataset from the TFRecord file(s) in Cloud Storage.
  imageDataset = tf.data.TFRecordDataset(imageFilesList, compression_type='GZIP')
  imageDataset = imageDataset.map(parse_image, num_parallel_calls=5)
  imageDataset = imageDataset.map(toTupleImage).batch(1)

  # Perform inference.
  print('Running predictions...')
  strat = tf.distribute.MirroredStrategy(devices=['/gpu:0', '/gpu:1'])
  with strat.scope():
  #with tf.device('/cpu'):
    m = tf.keras.models.load_model(MODEL_DIR, compile=False) 
    # print(m.summary())
    predictions = m.predict(imageDataset, steps=patches, verbose=1)
    labels = predictions.argmax(axis=3)
    # probabilities = predictions.arrayFlatten([['bg', 'corn', 'soy']])
    # label = predictions.arrayArgmax().arrayGet([0]).rename('label')
    # print(labels[0])

  print('Writing predictions...')
  out_image_file = FOLDER + '/' + out_image_base + '.TFRecord'
  writer = tf.io.TFRecordWriter(out_image_file)
  patches = 0
  for predictionPatch in labels:
    print('Writing patch ' + str(patches) + '...')
    predictionPatch = predictionPatch[
        x_buffer:x_buffer+KERNEL_SIZE, y_buffer:y_buffer+KERNEL_SIZE]

    # Create an example.
    example = tf.train.Example(
      features=tf.train.Features(
        feature={
          'cropland': tf.train.Feature(
              float_list=tf.train.FloatList(
                  value=predictionPatch.flatten()))
        }
      )
    )
    # Write the example.
    writer.write(example.SerializeToString())
    patches += 1
    # print(patches)

  writer.close()


YEAR = '20XX'
FOLDER = 'TFRecordÂ DATA FOLDER'  # This code expects the dierectory structure to be "folder_name/YEAR/STATE_Name"
MODEL_DIR = "s2_wSWIR_aug"
opticalBands = ['B2', 'B3', 'B4', 'B5', 'B6', 'B7']  # For Lamdsat 8, change to  corresponding names for Sentinel 2
BANDS = opticalBands 
RESPONSE = 'cropland'
FEATURES = BANDS + [RESPONSE]
NCLASS  =  3

# Specify the size and shape of patches expected by the model.
KERNEL_SIZE = 256
KERNEL_SHAPE = [KERNEL_SIZE, KERNEL_SIZE]
COLUMNS = [
  tf.io.FixedLenFeature(shape=KERNEL_SHAPE, dtype=tf.float32) for k in FEATURES
]
FEATURES_DICT = dict(zip(FEATURES, COLUMNS))




user_folder = 'users/username' # GEE username
kernel_buffer = [128, 128]

# The followinig is a sample snippet that uses the state of Michigan
# Modify according to your geometry
image_base = "Michigan_l8_" + YEAR # Modify accoerding to your own data and file mame scheme
US_states = ee.FeatureCollection('TIGER/2018/States')
geo = US_states.filter(ee.Filter.eq('STUSPS', 'MI')).getInfo()['features'][0]['geometry']

doPrediction(image_base, user_folder, kernel_buffer, geo)
